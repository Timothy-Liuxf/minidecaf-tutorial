# step4 实验指导

## 词法语法分析
如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。

语义检查无需修改。

手写分析根据生成式变化修改即可，变化很小。

## IR 生成
沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。

| 指令 | 参数 | 含义 | IR 栈大小变化 |
| --- | --- | --- | --- |
| `eq` | 无参数 | `==`（弹出栈顶两个元素，如果相等压入 1，否则压入 0） | 减少 1 |
| `ne` | 无参数 | ……`!=` | 减少 1 |
| `le` | 无参数 | ……`<=` | 减少 1 |
| `ge` | 无参数 | ……`>=` | 减少 1 |
| `lt` | 无参数 | ……`<` | 减少 1 |
| `gt` | 无参数 | ……`>` | 减少 1 |
| `land` | 无参数 | ……`&&` | 减少 1 |
| `lor` | 无参数 | 弹出栈顶两个元素，将其逻辑或压入栈 | 减少 1 |

> 这样设计的IR中，`&&`和`||`都是没有短路性质的。我们的语义规范要求是否实现短路性质都可以。

## 汇编生成
对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。

逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现`&&`和`||`，比较难以理解，所以下面直接给出 `land` 和 `lor` 对应的不使用跳转的汇编。
表格中，我们省略了汇编的前缀 `lw t1, 4(sp)  ;  lw t2, 0(sp)` 和后缀 `addi sp, sp, 4  ;  sw t1, 0(sp)`。
注意 RISC-V 汇编中的 `and` 和 `or` 都是位运算指令，不是逻辑运算指令。

| IR       | 汇编                                                |
| ---      | ---                                                 |
| `lor` | `or t1,t1,t2  ;  snez t1,t1` |
| `land` | `snez t1,t1  ;  snez t2,t2  ;  and t1,t1,t2` |

# 思考题

1. 在表达式计算时，对于某一步运算，是否一定要先计算出所有的操作数的结果才能进行运算？
2. 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？

# 总结
step4 和 step3 差别不大。
